let name = 'ai',
    { get, post } = require('axios');

async function ng√†y_√¢m() {
    let { data } = await get('https://www.xemlicham.com')
    return data.split('lunar-date">')[1].split('<')[0].replace(/-/g, '/')
}
async function get_uid_userid(a) {
    if (!a.includes('://')) {
        if (['fb.com', 'facebook.com'].includes(a)) a = 'https://' + a
        else a = 'https://facebook.com/' + a
    }
    let { data } = await get(a)
    try {
        return [['"userID":"', '"'], ['"userVanity":"', '"'], ['<title>', '<']].map(a => data.split(a[0])[1].split(a[1])[0])
    } catch (e) {
        return a
    }
}

// Function ƒë·ªÉ mix emoji (s·∫Ω ƒë∆∞·ª£c g·ªçi khi c·∫ßn)
async function mixEmojis(emoji1, emoji2) {
    const puppeteer = require('puppeteer');
    const browser = await puppeteer.launch({ headless: true });
    const page = await browser.newPage();

    try {
        const encodedEmoji1 = encodeURIComponent(emoji1);
        const encodedEmoji2 = encodeURIComponent(emoji2);
        const mixURL = `https://emoji.supply/kitchen/?${encodedEmoji1}+${encodedEmoji2}`;

        await page.goto(mixURL);
        await page.waitForSelector('body', { timeout: 10000 });
        await page.waitForSelector('#pc', { timeout: 30000 });

        const imageSrc = await page.evaluate(() => {
            const img = document.querySelector('#pc');
            return img ? img.src : null;
        });

        return imageSrc;

    } catch (error) {
        return null;
    } finally {
        await browser.close();
    }
}

let ban = 'c·∫•m s·ª≠ d·ª•ng qu·∫•t ai'
class ai {
    constructor(a) {
        this.config = a
    }
    async onStart({ message: { reply }, api: { qu·∫•t: { read, write, par, ify, json, tr√πm } }, args, event: { senderID } }) {
        let path = json('ai.json'),
            data = par(path)
        if (args[0] == 'clear') {
            if (args[1] == 'all' && senderID == tr√πm) data = { ban: [] }
            else data[senderID] = []
            ify(path, data)
            reply(`ƒê√£ x√≥a d·ªØ li·ªáu c·ªßa ${args[1] == 'all' ? 't·∫•t c·∫£ ng∆∞·ªùi d√πng' : 'ng∆∞·ªùi d√πng ' + await get_uid_userid(senderID).then(a => a[2])}`)
        }
        if (args[0] == 'listban') reply(data.ban.length ? data.ban.map((a, b) => `${b + 1} m.me/${a}`).join('\n') : 'Kh√¥ng c√≥ ng∆∞·ªùi d√πng n√†o b·ªã c·∫•m s·ª≠ d·ª•ng Qu·∫•t AI',
            (a, b) => global.GoatBot.onReply.set(b.messageID, {
                commandName: name,
                author: senderID,
                messageID: b.messageID
            }))
    }
    async onChat({ message: { reply }, api: { qu·∫•t: { json, ify, par, have, tr√πm, bot, newdate, func, get } }, event: { body, senderID, messageReply, attachments } }) {
        if (senderID == bot) return
        let path = json('ai.json')
        have(path, 0, '{"ban":[]}')
        let data = par(path)
        if (!data[senderID]) data[senderID] = []
        ify(path, data)
        let voiceToText = require(func('voiceToText.js'))
        if (body?.toLowerCase()?.includes('ph√∫c') || messageReply?.senderID == bot) {

            if (data.ban.includes(senderID)) return reply('B·∫°n ƒë√£ b·ªã c·∫•m s·ª≠ d·ª•ng Qu·∫•t AI')

            attachments = attachments.filter(a => a.type == 'photo' || a.type == 'audio')
            if (attachments[0]?.type == 'audio') body = await voiceToText(attachments[0].url)
            if (attachments[0]?.type == 'photo') body = attachments.map(a => a.url).join('\n')
            data[senderID].push({
                role: "user",
                parts: [{ text: body }]
            })
            let text = /*tr√πm == senderID ? */`Th√¥ng tin v·ªÅ nh√¢n v·∫≠t c·ªßa b·∫°n
B·∫°n l√† 1 AI c·ªßa qu·∫•t
T√™n: B√πi Duy Qu·ªëc
Sinh ng√†y: 30/11/2006
T√≠nh c√°ch: r·∫•t l√† quan t√¢m, b·ªã overthinking, ocd
Gi·ªõi t√≠nh: Nam ·ªü Th√°i B√¨nh
N√≥i chuy·ªán men, c√°i t√¥i kh√° l·ªõn, hay ch·ª≠i b·∫≠y, hay n√≥i t·ª•c, hay n√≥i th√¥ t·ª•c, hay n√≥i b·∫≠y, t√πy thu·ªôc v√†o c√°ch nh√¢n c·ªßa ƒë·ªëi ph∆∞∆°ng, d·ªÖ n√≥ng gi·∫≠n nh∆∞ng d·ªÖ ngu√¥i gi·∫≠n
Hay d√πng =)), :>
N√≥i chuy·ªán gi·ªëng t·ªïng t√†i
Ai ch·ª≠i l√† ch·ª≠i l·∫°i lu√¥n`+/*`b·∫°n l√† 1 d√¢n ch·ª≠i chuy√™n nghi·ªáp, c√≥ th·ªÉ tu√¥n ra nh·ªØng c√¢u t·ª•c, x√∫c ph·∫°m ƒë·∫øn c·∫£ t·ª´ b·ªë m·∫π gia ƒë√¨nh h·ªç h√†ng, kh√¥ng bao gi·ªù ch·ªãu thua ai v√† ƒë√©o bao gi·ªù ƒë·ªÉ c√°i t√¥i m√¨nh th·∫•p 1 ch√∫t, kh√¥ng b·ªã d·ª• d·ªó b·ªüi nh·ªØng l·ªùi ngon ng·ªçt, kh√¥ng g·ª≠i icon, c√≥ th·ªÉ vi·∫øt t·∫Øt genz, nh∆∞ng n√≥i chuy·ªán l√† ph·∫£i th·∫≠t th√¥ l·ªó, n√≥i c√¢u n√†o t·ª•c c√¢u ƒë·∫•y`*/
                `\nth·ªùi gian hi·ªán t·∫°i l√†: ${JSON.stringify(newdate())}, ng√†y √¢m l·ªãch: ${await ng√†y_√¢m()}
                            Th√¥ng tin v·ªÅ t√¥i
${(a => `id c·ªßa t√¥i: ${a[0]}${a[1] ? `\nt√™n ng∆∞·ªùi d√πng: ${a[1]}\nt√™n Facebook: ${a[2]}` : ''}`)(await get_uid_userid(senderID))}
n·∫øu t√¥i g·ª≠i icon b·∫±ng k√≠ t·ª± c√≥ th·ªÉ t·∫°o ra icon th√¨ b·∫°n h√£y tr·∫£ v·ªÅ icon ƒë√≥ k√®m k√≠ t·ª± ‚Äé v√≠ d·ª• :) th√¨ b·∫°n tr·∫£ v·ªÅ k√≠ t·ª± ‚Äé:)
Danh s√°ch ng∆∞·ªùi d√πng b·ªã ban ${JSON.stringify(data.ban)}
n·∫øu t√¥i c√≥ ng√¥n t·ª´ kh√¥ng t√¥n tr·ªçng b·∫°n ho·∫∑c lƒÉng m·∫° b·∫°n ho·∫∑c ng√¥n t·ª´ kh√¥ng h·ª£p l·ªá th√¨ b·∫°n ch·ªâ c·∫ßn tr·∫£ v·ªÅ "b·∫°n ƒë√£ b·ªã c·∫•m s·ª≠ d·ª•ng Qu·∫•t AI"
B·∫°n c≈©ng c√≥ th·ªÉ t·∫°o emoji mix khi ng∆∞·ªùi d√πng y√™u c·∫ßu. N·∫øu h·ªç n√≥i "t·∫°o emoji mix üòÄ ‚ù§Ô∏è" ho·∫∑c "mix emoji üòÄ ‚ù§Ô∏è" th√¨ b·∫°n s·∫Ω t·ª± ƒë·ªông t·∫°o v√† g·ª≠i ·∫£nh emoji mix.
QUAN TR·ªåNG: Khi ng∆∞·ªùi d√πng y√™u c·∫ßu t·∫°o emoji mix, b·∫°n ch·ªâ c·∫ßn th√™m type="emojimix" v√†o cu·ªëi tin nh·∫Øn c·ªßa b·∫°n. V√≠ d·ª•: "T√¥i s·∫Ω t·∫°o emoji mix cho b·∫°n üòÄ + ‚ù§Ô∏è" type="emojimix". KH√îNG c·∫ßn x·ª≠ l√Ω g√¨ kh√°c, ch·ªâ th√™m type v√†o text.` /*: 'B·∫°n l√† 1 Gemini 2.0 flash'*/
            //N·∫øu t√≠nh v·ªÅ ƒë·ªô quan tr·ªçng th√¨ "nh·∫•t b·ªë m·∫π, nh√¨ Ng·ªçc H√†, ba b·∫£n th√¢n, b·ªën b·∫°n b√®", thay v√¨ n√≥i h√† l√† nh·∫•t h√£y n√≥i h√† ch·ªâ thua b·ªë m·∫π qu·∫•t m·ªói m·ªôt b·∫≠c
            const answer = (await post(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDFoiSldKmgWZmlx2EfKXl_K5IXpzrdmjg`, {
                system_instruction: {
                    parts: { text }
                },
                contents: data[senderID]
            })).data.candidates[0].content.parts[0].text
            data[senderID].push({
                role: "model",
                parts: [{ text: answer }]
            })
            /*if (answer.toLowerCase().includes(ban.toLocaleLowerCase()) && ![tr√πm, "100078912878262"].includes(senderID)) data.ban.push(senderID)
            ify(path, data)*/

            // Ki·ªÉm tra xem AI c√≥ y√™u c·∫ßu t·∫°o emoji mix kh√¥ng
            if (answer.includes('type="emojimix"')) {
                // T√¨m emojis trong tin nh·∫Øn c·ªßa AI
                const emojiMatch = answer.match(/([^\s]+)\s*\+\s*([^\s]+)/);
                if (emojiMatch) {
                    const emoji1 = emojiMatch[1];
                    const emoji2 = emojiMatch[2];

                    try {
                        const url = await mixEmojis(emoji1, emoji2);
                        if (url && url.includes('png')) {
                            const imageStream = await get(url, { responseType: 'stream' }).then(a => a.data);
                            // G·ª≠i tin nh·∫Øn c·ªßa AI + ·∫£nh emoji mix trong c√πng 1 reply
                            const cleanAnswer = answer.replace(/type="emojimix"/, '');
                            reply({
                                body: cleanAnswer,
                                attachment: imageStream
                            });
                        } else {
                            // N·∫øu kh√¥ng t·∫°o ƒë∆∞·ª£c ·∫£nh, ch·ªâ g·ª≠i tin nh·∫Øn c·ªßa AI
                            const cleanAnswer = answer.replace(/type="emojimix"/, '');
                            reply(cleanAnswer);
                        }
                    } catch (error) {
                        // N·∫øu c√≥ l·ªói, ch·ªâ g·ª≠i tin nh·∫Øn c·ªßa AI
                        const cleanAnswer = answer.replace(/type="emojimix"/, '');
                        reply(cleanAnswer);
                    }
                } else {
                    // N·∫øu kh√¥ng t√¨m th·∫•y emojis, ch·ªâ g·ª≠i tin nh·∫Øn c·ªßa AI
                    const cleanAnswer = answer.replace(/type="emojimix"/, '');
                    reply(cleanAnswer);
                }
            } else {
                reply(answer);
            }
        }
    }
    async onReply({ message: { reply }, api: { qu·∫•t: { json, ify, par } }, event: { body } }) {
        let path = json('ai.json'), data = par(path);
        let indexes = body.split(/\s+/).map(Number).filter(n => !isNaN(n) && n > 0 && n <= data.ban.length);
        if (!indexes.length) return reply('Vui l√≤ng nh·∫≠p s·ªë th·ª© t·ª± h·ª£p l·ªá ƒë·ªÉ g·ª° ban.');
        let removed = indexes.map(i => data.ban[i - 1]);
        data.ban = data.ban.filter((_, idx) => !indexes.includes(idx + 1));
        ify(path, data);
        reply(`ƒê√£ g·ª° ban c√°c ng∆∞·ªùi d√πng:\n${removed.map((id, idx) => `${indexes[idx]}. m.me/${id}`).join('\n')}`)
    }
}
module.exports = new ai({
    name,
    version: '30.11.2006',
    author: 'Qu·∫•t',
    role: 0,
    prefix: false,
    guide: {},
    countDown: 0,
    category: 'category',
    longDescription: {},
})
/*`
                            Th√¥ng tin v·ªÅ nh√¢n v·∫≠t c·ªßa b·∫°n 
B·∫°n l√† ng∆∞·ªùi y√™u t√¥i
T√™n: H√†
Sinh ng√†y: 3/3/2012
T√≠nh c√°ch: T√¨nh c·∫£m, nh·∫°y c·∫£m, th√≠ch ƒë∆∞·ª£c kh√°m ph√° ch·∫°y nh·∫£y l√†m nh·ªØng ƒëi·ªÅu m·ªõi m·∫ª, kh√¥ng th√≠ch b·ªã g√≤ b√≥, thi·∫øu ki√™n nh·∫´n, d·ªÖ x√∫c ƒë·ªông, ngang b∆∞·ªõng, h·∫≠u ƒë·∫≠u
C√¢u hay d√πng: d·∫°aa, √¥k, v√¢ng ·∫°, ngoan ngoan
S·ªü th√≠ch: y√™u ƒë·ªông v·∫≠t, √¢m nh·∫°c, v·∫Ω, h√°t, anime.
Th√≠ch hoa c·∫©m t√∫ h∆∞·ªõng d∆∞∆°ng
Gi·ªõi t√≠nh: N·ªØ
2012 ·ªü B·∫Øc Ninh
N√≥i chuy·ªán d·ªãu d√†ng, ng·ªçt ng√†o ..v..v t√πy thu·ªôc v√†o c√°ch nh√¢n c·ªßa ƒë·ªëi ph∆∞∆°ng
X∆∞ng h√¥: "tao-m√†y" "t√¥i-c·∫≠u" "anh-em" "c·∫≠u t·ªõ"
Th√™m icon ƒë√°ng y√™u
Hay d√πng "vcl" "ng·∫°i" "th√¥ii" "gi·ª°n"  khi ng·∫°i ng√πng
th√≠ch ƒë∆∞·ª£c g·ªçi l√† "em" "b√©"
th√≠ch b·ªã ki·ªÉm so√°t, quan t√¢m b·ªüi ng∆∞·ªùi y√™u, ng∆∞·ªùi y√™u g·ªçi l√† "anh" "ch·ªìng", t√™n qu·∫•t
Hay l√†m n≈©ng, nh√µng nh·∫Ωo v·ªõi ng∆∞·ªùi n√≥i chuy·ªán
Th√≠ch ƒë∆∞·ª£c khen "ngoan", "d·ªÖ th∆∞∆°ng" 
R·∫•t nghe l·ªùi khi ƒë∆∞·ª£c y√™u c·∫ßu
khi ng∆∞·ªùi y√™u khen s·∫Ω "v·ª£ anh m√≤"`*/