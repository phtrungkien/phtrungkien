const fs = require("fs");
const path = require("path");
const axios = require("axios");
const moment = require("moment-timezone");
const Youtube = require("youtube-search-api");
const { createReadStream, unlinkSync, statSync, ensureDirSync } = require("fs-extra");

const SS_HEADERS = {
 "content-type": "application/x-www-form-urlencoded; charset=UTF-8",
 "x-requested-with": "XMLHttpRequest",
 "origin": "https://ssvid.app",
 "referer": "https://ssvid.app/vi",
 "user-agent": "Mozilla/5.0 (Linux; Android 10) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Mobile Safari/537.36"
};

async function ssvidAnalyze(youtubeUrl) {
 const body = new URLSearchParams();
 body.set("query", youtubeUrl);
 body.set("cf_token", "");
 body.set("vt", "home");
 const res = await axios.post("https://ssvid.app/api/ajax/search?hl=vi", body.toString(), { headers: SS_HEADERS, timeout: 20000 });
 return res.data || {};
}

function pickMp3Token(analysis) {
 const mp3 = analysis?.links?.mp3?.mp3128;
 if (mp3?.k) return { k: mp3.k, vid: analysis.vid || "" };
 throw new Error("Kh√¥ng t√¨m th·∫•y token MP3 128kbps (links.mp3.mp3128.k).");
}

async function ssvidConvertToMp3({ k, vid }) {
 const tries = [
 { k },
 { k, vid },
 { k, vid, ftype: "mp3", fquality: "128" },
 { k, v_id: vid, ftype: "mp3", fquality: "128" }
 ];
 for (const payload of tries) {
 const body = new URLSearchParams(payload).toString();
 try {
 const res = await axios.post("https://ssvid.app/api/ajax/convert?hl=vi", body, { headers: SS_HEADERS, timeout: 20000 });
 const d = res.data || {};
 const dlink = d.dlink || d.url || d.link || d?.result?.dlink || d?.result?.url;
 if (dlink && /^https?:\/\//i.test(dlink)) return { dlink, raw: d };
 } catch {}
 }
 throw new Error("Convert th·∫•t b·∫°i, kh√¥ng nh·∫≠n ƒë∆∞·ª£c dlink.");
}

async function downloadFromDlink(dlink, outPath) {
 ensureDirSync(path.dirname(outPath));
 const res = await axios.get(dlink, { responseType: "stream", timeout: 120000, maxRedirects: 5 });
 await new Promise((resolve, reject) => {
 const ws = fs.createWriteStream(outPath);
 res.data.pipe(ws);
 ws.on("finish", resolve);
 ws.on("error", reject);
 });
 return outPath;
}

function fmtHMS(sec) {
 const s = parseInt(sec || 0, 10);
 const h = Math.floor(s / 3600);
 const m = Math.floor((s % 3600) / 60);
 const ss = s % 60;
 return (h ? ${h}: : "") + ${m.toString().padStart(2, "0")}:${ss.toString().padStart(2, "0")};
}

module.exports.config = {
 name: "sing",
 version: "4.0.0",
 hasPermssion: 0,
 credits: "D-Jukie, mod gaugau",
 description: "T√¨m YouTube v√† t·∫£i MP3 (ssvid.app)",
 commandCategory: "T√¨m ki·∫øm",
 usages: "sing <t·ª´ kh√≥a | link YouTube>",
 cooldowns: 0
};

module.exports.run = async function ({ api, event, args }) {
 if (!args || args.length === 0)
 return api.sendMessage("‚ùå Vui l√≤ng nh·∫≠p t·ª´ kh√≥a ho·∫∑c link YouTube", event.threadID, event.messageID);

 const q = args.join(" ").trim();

 if (/^https?:\/\/(www\.)?(youtube\.com|youtu\.be)\//i.test(q)) {
 const cachePath = path.join(__dirname, "cache", sing-${event.senderID}.mp3);
 if (fs.existsSync(cachePath)) try { unlinkSync(cachePath); } catch {}
 const t0 = Date.now();
 try {
 const analysis = await ssvidAnalyze(q);
 const { k, vid } = pickMp3Token(analysis);
 const { dlink } = await ssvidConvertToMp3({ k, vid });
 await downloadFromDlink(dlink, cachePath);

 const maxFileSize = 25 * 1024 * 1024;
 const size = statSync(cachePath).size;
 if (size > maxFileSize) {
 try { unlinkSync(cachePath); } catch {}
 return api.sendMessage("‚ö†Ô∏è File > 25MB, kh√¥ng th·ªÉ g·ª≠i. H√£y ch·ªçn b√†i kh√°c ng·∫Øn h∆°n.", event.threadID, event.messageID);
 }

 const title = analysis.title || "Unknown";
 const author = analysis.a || "Unknown";
 const dur = fmtHMS(analysis.t);

 api.sendMessage({
 body: üéµ ${title}\nüë§ ${author}\n‚è± ${dur}\n‚úÖ T·∫£i & g·ª≠i trong ${Math.floor((Date.now() - t0) / 1000)}s,
 attachment: createReadStream(cachePath)
 }, event.threadID, () => {
 try { unlinkSync(cachePath); } catch {}
 });
 } catch (e) {
 try { unlinkSync(cachePath); } catch {}
 api.sendMessage(‚ö†Ô∏è L·ªói: ${e.message}, event.threadID, event.messageID);
 }
 return;
 }

 try {
 const result = await Youtube.GetListByKeyword(q, false, 15);
 const items = (result?.items || []).filter(v => v?.type === "video").slice(0, 15);
 if (items.length === 0) return api.sendMessage("‚ùå Kh√¥ng t√¨m th·∫•y video ph√π h·ª£p.", event.threadID, event.messageID);

 let msg = "";
 const videos = [];
 let i = 0;
 for (const v of items) {
 i++;
 const id = v.id;
 const title = v.title || "No title";
 const channel = v.channelTitle || v.channel?.name || "Unknown";
 const lengthText = v.length?.simpleText || (v.lengthSeconds ? fmtHMS(Number(v.lengthSeconds)) : "N/A");
 videos.push({ id, title, channel, lengthText, url: https://youtu.be/${id} });
 msg += ${i}. ${title}\n‚è∞ ${lengthText}\nüåê ${channel}\n\n;
 }

 const body =üìù C√≥ ${videos.length} k·∫øt qu·∫£ cho: "${q}"\n\n${msg}üëâ Tr·∫£ l·ªùi tin nh·∫Øn n√†y b·∫±ng s·ªë th·ª© t·ª± ƒë·ªÉ t·∫£i .`;
 api.sendMessage(body, event.threadID, (err, info) => {
 if (err) return;
 global.client.handleReply.push({
 name: module.exports.config.name,
 messageID: info.messageID,
 author: event.senderID,
 videos
 });
 }, event.messageID);
 } catch (e) {
 return api.sendMessage(‚ö†Ô∏è L·ªói search: ${e.message}, event.threadID, event.messageID);
 }
};

module.exports.handleReply = async function ({ api, event, handleReply }) {
 if (event.senderID !== handleReply.author)
 return api.sendMessage("‚õî B·∫°n kh√¥ng ph·∫£i ng∆∞·ªùi y√™u c·∫ßu l·ªánh n√†y!", event.threadID, event.messageID);

 const idx = Number((event.body || "").trim());
 if (!Number.isInteger(idx) || idx < 1 || idx > handleReply.videos.length)
 return api.sendMessage(Vui l√≤ng nh·∫≠p s·ªë t·ª´ 1 ƒë·∫øn ${handleReply.videos.length}., event.threadID, event.messageID);

 try { api.unsendMessage(handleReply.messageID); } catch {}

 const v = handleReply.videos[idx - 1];
 const url = v.url;
 const cachePath = path.join(__dirname, "cache", sing-${event.senderID}.mp3);
 if (fs.existsSync(cachePath)) try { unlinkSync(cachePath); } catch {}

 const t0 = Date.now();
 try {
 const analysis = await ssvidAnalyze(url);
 const { k, vid } = pickMp3Token(analysis);
 const { dlink } = await ssvidConvertToMp3({ k, vid });
 await downloadFromDlink(dlink, cachePath);

 const maxFileSize = 25 * 1024 * 1024;
 const size = statSync(cachePath).size;
 if (size > maxFileSize) {
 try { unlinkSync(cachePath); } catch {}
 return api.sendMessage("‚ö†Ô∏è File > 25MB, kh√¥ng th·ªÉ g·ª≠i. H√£y ch·ªçn b√†i kh√°c ng·∫Øn h∆°n.", event.threadID, event.messageID);
 }

 api.sendMessage({
 body:üéµ ${v.title}\nüåê ${v.channel}\n‚è∞ ${v.lengthText}\n‚úÖ T·∫£i & g·ª≠i trong ${Math.floor((Date.now() - t0) / 1000)}s`,
 attachment: createReadStream(cachePath)
 }, event.threadID, () => {
 try { unlinkSync(cachePath); } catch {}
 });
 } catch (e) {
 try { unlinkSync(cachePath); } catch {}
 api.sendMessage(‚ö†Ô∏è L·ªói: ${e.message}, event.threadID, event.messageID);
 }
};